---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  cache = TRUE,
  cache.path = "man/cache/"
)
library(rstan)
rstan_options(threads_per_chain = parallel::detectCores())
```

# RStanTVA

<!-- badges: start -->
[![R](https://github.com/mmrabe/RStanTVA/actions/workflows/rpkg.yml/badge.svg)](https://github.com/mmrabe/RStanTVA/actions/workflows/rpkg.yml)
<!-- badges: end -->

RStanTVA is an R package containing the StanTVA library and numerous convenience functions for generating, compiling, fitting, and analyzing (Stan)TVA models.

## Installation

You can install the development version of RStanTVA from [GitHub](https://github.com/mmrabe/RStanTVA) with:

``` r
remotes::install_github("mmrabe/RStanTVA")
```

## Loading the library

```{r example-load}
library(RStanTVA)
library(tidyverse)
```

## Simple example

Load data of simulated subject 20 in condition `high` from the parameter recovery study data set `tva_recovery`:

```{r example-data}
tva_data <- tva_recovery %>% filter(subject == 20 & condition == "high")
tva_data
```


Generate a StanTVA model for partial report of 6 display locations with Gaussian $t_0$ and a free $K$ distribution:

```{r example-model, warning=FALSE, message=FALSE, results=FALSE}
tva_model <- stantva_model(
  locations = 6,
  task = "pr",
  w_mode = "locations",
  t0_mode = "gaussian",
  K_mode = "free",
  sanity_checks = FALSE
)
```


```{r show-model}
tva_model
```


The generated Stan code looks like this:

```{r show-model-code, results = 'asis', echo = FALSE}
conf <- tva_model@code@config
conf$parallel <- FALSE
cat("``` stan\n")
write_stantva_model(do.call(stantva_code, conf))
cat("```\n")
```


Fit `tva_model` to the `tva_data` using maximum-likelihood estimation (MLE):

```{r example-fit-mle}
tva_fit_mle <- optimizing(tva_model, tva_data)
tva_fit_mle$par[c("C","alpha","mu0","sigma0")]
```


Fit `tva_model` to the `tva_data` using maximum-likelihood estimation (MLE):

```{r example-fit, eval=TRUE}
tva_fit <- sampling(tva_model, tva_data)
tva_fit
```


## Nested example

Load data of simulated subject 20 in both condition (`high` and `low`) from the parameter recovery study data set `tva_recovery`:

```{r example-nested-data}
tva_data_nested <- tva_recovery %>% filter(subject == 20)
tva_data_nested
```


Generate a StanTVA model for partial report of 6 display locations with Gaussian $t_0$ and a free $K$ distribution:

```{r example-nested-model, warning=FALSE, message=FALSE, results=FALSE}
tva_model_nested <- stantva_model(
  formula = list(
    log(C) ~ 1 + condition
  ),
  locations = 6,
  task = "pr",
  w_mode = "locations",
  t0_mode = "gaussian",
  K_mode = "free",
  sanity_checks = FALSE
)
```

Note that we are allowing $C$ to vary between experimental conditions. This will add another "layer" to the model, which implements $C$ in trial $i$, $C_i$, as:

$$
\log\left(C_i\right) = \alpha_C+\beta_CX_i
$$

As a consequence, $C$ is no longer estimated as a single invariant parameter but as the exp-sum of an intercept $\alpha_C$, and the product of slope $\beta_C$ and experimental condition $X_i$, coded here using standard treatment contrasts.

The generated Stan code looks like this:

```{r show-nested-model-code, results = 'asis', echo = FALSE}
conf <- tva_model_nested@code@config
conf$parallel <- FALSE
cat("``` stan\n")
write_stantva_model(do.call(stantva_code, conf))
cat("```\n")
```



Fit `tva_model_nested` to the `tva_data_nested` using maximum-likelihood estimation (MLE):

```{r example-fit-nested, eval=TRUE}
tva_fit_nested <- sampling(tva_model_nested, tva_data_nested)
tva_fit_nested
```


## Hierarchical example

Generate a hierarchical TVA model:

```{r example-hierarchical, warning=FALSE, message=FALSE, results=FALSE}


priors <-
  prior(normal(0,.07),dpar=C)+
  prior(normal(4,.2),dpar=C,coef=Intercept)+
  prior(normal(0,.07),dpar=alpha)+
  prior(normal(-0.2,.1),dpar=alpha,coef=Intercept)+
  prior(normal(0,.03),dpar=pK)+
  prior(normal(0,.1),dpar=pK,coef=Intercept)+
  prior(normal(0,5),dpar=mu0)+
  prior(normal(30,15),dpar=mu0,coef=Intercept)+
  prior(normal(0,.04),dpar=sigma0)+
  prior(normal(0,.2),dpar=sigma0,coef=Intercept)+
  prior(normal(0,.05),dpar=w)+
  prior(normal(0,0.1),dpar=w,coef=Intercept)

tva_hierarchical_model <- stantva_model(
  formula = list(
    log(C) ~ 1 + condition + (1 + condition | C_alpha | subject),
    log(w) ~ 1 + (1 | subject),
    log(pK) ~ 1 + (1 | subject),
    mu0 ~ 1 + (1 | subject),
    log(sigma0) ~ 1 + (1 | subject),
    log(alpha) ~ 1 + (1 | C_alpha | subject)
  ),
  locations = 6,
  task = "pr",
  w_mode = "locations",
  t0_mode = "gaussian",
  K_mode = "free",
  priors = priors
)

```


Fit hierarchical `tva_hierarchical_model` to the first 200 trials of the first 10 subjects of the `tva_recovery` data set:

```{r show-hierarchical-fit, eval=FALSE}

tva_hierarchical_subset <- tva_recovery %>% filter(subject <= 10 & trial <= 200)

tva_hierarchical_fit <- sampling(tva_hierarchical_model, tva_hierarchical_subset, refresh = 20)

tva_hierarchical_fit

```


